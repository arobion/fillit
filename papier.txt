L'on distingue 2 parties a la resolution de fillit : 
1) la partie algorythmique
2) la partie lecture des pieces et gestion d'erreures

1)ALGO
le but est de placer les pieces de tetris dans le plus petit carre possible. 
---1ere idee : backtracking pur et dur ( risque de timeout) : on place la 1ere piece, on place la 2eme, on place la 3eme, etc, puis on sauvegarde la taille du carre, et on recommence en deplacant la derniere piece de 1 et en sauvegardant la taille du carre si elle est inferieur a celle en memoire.
---2eme idee : a partir d'une formule etudiee pour, determiner la taille du carre min de destination, et y effectuer un algo de type 1ere idee dans ce carre
--idee pour la formule : chaque triomino occupe une place de 4 cases. le carre minimum est donc d'une aire de nbtrio * 4, soit un carre de cote c = racine(nbtrio*4). neanmoins cela n'est vrai que dans un cas d'emboitement parfait, ce qui evidemment n'est quasiement jamais le cas. Il faut donc determiner le nombre max de "trous" qui serait le pire des cas. dans le pire des cas, une piece peut creer un nombre de trous equivalent a son perimetre. cad 8. donc le carre serait de cote c = racine(12*nbtrio).
---3eme idee : on place

si nb trou + aire des pieces > aire du carre mini, retry. si toute possibilitees ont etes essayyee sur le carre mini, augmenter c++.



PARTIE "PARSING"
1ere etape : lire et stocker le fichir dans un "tableau entier ?" "double tableau ?" 
2eme etape : verifier que le fichier est valide : 
1) tetriminos invalide : plus ou moins de 4 lignes, plus ou moins de 4 colonnes, plusieurs symboles sur le "carre de definition ", plus ou moins de 4 cases, plus de 26 piece ou moins de 1 piece, plus ou moins de 1 ligne d'ecart entre 2 "declarations" de tetriminos.
lors de la lecture, une piece est detectee lors d'un double saut de ligne. 
on stock tout dans une unique chaine de caracteres de taille nbtrios * 16. puis on remplace chaque piece par sa lettre correspondate.
tout les 16 char, represente une coupure de piece.
on cree une chaine de taille carre parfait +1.
on tente l'algo, si ft_remp(carr ideal), on relance ft_remp(carr ideal ++).
comment calculer les trous ?
au depart, la map a remplire est pleine de points. si le 4 cotes a cote sont "pleins" (cad les 4 adjacents != .) on incremente "com`pteur de trous."
